%% md
# Neuro-choropleth 

This is a tool to efficiently perform initial analyses of neuro imaging multi subject scans. 
%% fetch
json: atlas = https://raw.githubusercontent.com/DevinBayly/neuro-choro/HCP/src/GeoJson_Brains/totalfix.json



%% md
<div id="applicationHolder"></div>
%% css

#allpanes {
  display:flex;
}


#radcontaineraxial::before {
  content:"brainviews: ";
  display:block;
  text-decoration:underline;
}

#radcontainercoronal::after {
  content:"Region Color Column";
  display:block;
  text-decoration:underline;
}

.pane {
    border: 1px 
    black solid;
    border-radius: 20px;
    padding: 10px;
}
#regionname {
    background:  #dbdbba;
}
.infoHolder {
  display:flex;
}
.tooltipholder {
    width:50%;
    font-size: 12px;
    border: 1px black solid;
    border-radius: 20px;
    text-align: center;
}
%% js
class Application {
  /**
   *Creates an instance of Application. Also creates a panes list to hold each generated pane
   * @param {*} applicationHolder This is the page div that the elements should live within. Useful for Iodide where the document.body.append causes issues within the IDE side of it.
   * @param {*} [jsonData={}] this is the data that specifies the region boundaries of the json data. it is shared between all panes
   * @class Application
   */
  constructor(applicationHolder, jsonData = {}) {
      debugger
    // create the button
    /**  */
    this.panes = []
    /**  */
    this.regionBoundaryData = jsonData
    /**  */
    this.applicationHolder = applicationHolder
  }
  /**
   * This function is the application side of pane removal, there's another function used in the pane class, but this will ensure that the correct pane is taken out of the pane list 
   * @param {*} id this is the tagid of the pane that should get removed
   */
  removePane(id) {
    for (let ind = 0;ind < this.panes.length;ind++) {
      let pane = this.panes[ind]
      if (pane.paneDiv.id == id) {
        // splice out the specific pane
        this.panes.splice(ind,1)
      }
    }
  }
  /**
   *Calls the add button option to create panes for your exploratory investigation of the fMRI data
   *
   * @memberof Application
   */
  runApp() {
    this.addButton()
    this.allPanes = document.createElement("div")
    this.allPanes.id = "allpanes"
    this.applicationHolder.append(this.allPanes)
  }
  /**
   *Generates a button within the application holder for creating panes, exporting the session, and importing
   *
   * @memberof Application
   */
  async addButton() {
    // fetch the region boundary data
    /**  */
    this.btndiv = document.createElement("div")
    this.btndiv.id = "btnholder"
    /**  */
    this.btn = document.createElement("button")
    this.btn.onclick = this.addPane.bind(this)
    this.btn.setAttribute("id", "addbtn")
    this.btn.innerHTML = "Add Pane"
    this.btndiv.append(this.btn)
    this.applicationHolder.append(this.btndiv)
    // create the export button also 
    /**  */
    this.exportBtn = document.createElement("button")
    this.exportBtn.innerHTML = "Export"
    this.exportBtn.addEventListener("click", this.export.bind(this))
    this.applicationHolder.append(this.exportBtn)
    // create the import button
    /**  */
    this.importBtn = document.createElement("button")
    this.importBtn.innerHTML = "Import"
    this.importBtn.addEventListener("click", this.import.bind(this))
    this.applicationHolder.append(this.importBtn)
  }
  /**
   *Allows for the importing and initialization of panes from a previous session of investingation. Must dispatch most of the events that are generated by the user otherwise.
   *
   * @memberof Application
   */
  async import() {
      // do a fetch for a file 
    let readFile = (e) => {
      fetch(URL.createObjectURL(e.target.files[0]))
        .then(res => {
            return res.json()
        })
        .then(contents => {
            // run the application session loader
            this.sessionRecreator(contents)
        })
    }
      let inputFile = document.createElement("input")
      inputFile.type = "file"
      inputFile.onchange = readFile
      // trigger the opening of a file explorer window
      inputFile.click()
    // iterate over the panes

  }
  async sessionRecreator(importData) {
    for (let pane of importData.panes) {
      console.log(pane)
      await this.addPane()
      // select correct options
      let activePane = this.panes[this.panes.length - 1]
      // set the csvData from the pane to the paneObcsvText
      activePane.csvText = pane.csvText
      // find way to make it to createSelector
      debugger
      this.ctrlop.csvDataReader()
      this.ctrlop.createSelector()
      // set the fillCol to the previous 
      let fillSelector = activePane.paneDiv.querySelector("#fillCol")
      fillSelector.value = pane.fillColValue
      // emit change event to trigger drawing
      fillSelector.dispatchEvent(new Event("change"))

      // set the view correctly,
      activePane.brainView = pane.brainView
      let radio = activePane.paneDiv.querySelector(`#radio${pane.brainView}`)
      radio.checked = true
      // set the slice of the view 
      let slider = activePane.paneDiv.querySelector("#rangeslider")
      slider.value = pane.sliderIndex
      // dispatch the event that draws the canvas for the slider change
      slider.dispatchEvent(new Event("input"))
      // add info to the fillFilter boxes
      // but not all sessions will use it so check first
      if (pane.valFilterMax) {
        activePane.updateFillFilter(pane.valFilterMin, pane.valFilterMax)
      }
      if (pane.altFiltersState) {
        // iterate over the altfilters used
        let btn = activePane.paneDiv.querySelector("#altfilterbutton")
        for (let key in pane.altFiltersState) {
          let filterSettings = pane.altFiltersState[key]
          // click to generate a filter row
          btn.click()
          // query to find colVal selector
          // take the last which will be the most recent addition
          let row = Array(...document.querySelectorAll(".altFilterRow")).pop()
          let rowSelect = row.querySelector("#colname")
          // assign value to the selector from import
          // NOTE requires the correct csv to be loaded already too
          rowSelect.value = filterSettings.colname
          rowSelect.dispatchEvent(new Event("change"))
          // select the correct operations values too
          let op = row.querySelector("#op")
          op.value = filterSettings.op
          let val = row.querySelector("#val")
          val.value = filterSettings.val
          // emit a changed to trigger masking
          val.dispatchEvent(new Event("change"))
        }
      }
      // import the tooltips that were active on the pane last session 
      if (pane.rois) {
        for (let roi in pane.rois) {
          activePane.rois[roi] = pane.rois[roi]
        }
      }
      if (pane.ta) {
        activePane.ta.value = pane.ta
      }
    }
  }
  /**
   *Allows for the Exporting of a session as a JSON file. Iterates over the panes, and takes all the existing attributes of the pane object minus the regionBoundaryData (13mb file). Creates a link element and a download name with a datestring at the time of export, and offers to download and save in the iodide notebook if you have signed in
   *
   * @memberof Application
   */
  export() {
    // create the export ob
    let expOb = { panes: [] }
    // iterate over the panes
    for (let pane of this.panes) {
      // collect the relevant information
      // omit the boundary file
      let { regionBoundaryData, application, ...rest } = pane
      rest.ta = pane.ta.value
      expOb.panes.push(rest)
    }
    let a = document.createElement("a")
    let today = new Date()
    let datename = `neuro_choropleth_session_${today.getFullYear()}_${today.getMonth()}_${today.getDate()}_${today.getHours()}_${today.getSeconds()}.json`
    a.download = datename    // note that the date elements start with 0 so december is going to be tthe 11th month, and jan is the 0th
    a.href = URL.createObjectURL(new Blob([JSON.stringify(expOb)]))
    a.click()
    // also allow to save in this notebook
    iodide.file.save(datename, 'json', expOb, { overwrite: true });


  }
  /**
   *Generation of elements that live within a pane in the application such as the ctrl options and the canvas. Attach a unique ID to the pane, region data, and csvData. Then create and initialize ctrloptions and canvas passing the paneholder and the pane object. Lastly add the pane to the application panes list
   *
   * @memberof Application
   */
  async addPane() {
    let newPane = new Pane(this.allPanes, this.panes.length)
    // pass reference to pane, to be used by ctrlOp and Canvas
    newPane.regionBoundaryData = this.regionBoundaryData
    // set the application removal function accessible in the newPane
    newPane.removeFromApplication = this.removePane.bind(this)

    // here's the point where we can connect up the various parts
    // finish pane loading

    // create ctrloptions
    /**  */
    this.ctrlop = new CtrlOp(newPane.paneDiv, newPane)
    // loads the data and such
    await this.ctrlop.init()

    // create the canvas
    /**  */
    this.can = new Canvas(newPane.paneDiv, newPane, 500, 20)
    this.can.init()
    // target the canvas with our events
    this.ctrlop.target(this.can.can)

    this.panes.push(newPane)
  }
}

class Pane {
  /**
   *Creates an instance of Pane. Initiates construction of the ctrl op object for the pane all the buttons and stuff that have control over the canvas. Initiates creation of the canvas
   * @param {*} allPanes This is the element that the pane will live within. Used in Iodide Notebook
   * @param {*} count This is the ID of the pane, helps track how many have been created.
   * @class Pane
   */
  constructor(allPanes, count) {
    // generate the pane div
    // want radio w 3 buttons, range slider, selection form for loading
    let paneDiv = document.createElement("div")
    paneDiv.className = "pane"
    paneDiv.setAttribute("id", "pane" + count)
    /**  */
    this.paneDiv = paneDiv
    /** */
    this.removeIcon = new Image()
    // xicon is a global created at the top of the notebook
    this.removeIcon.src = "https://raw.githubusercontent.com/DevinBayly/neuro-choro/iodide/x.png"
    this.removeIcon.id = "paneremoveicon"
    this.removeIcon.addEventListener("click",this.removePane.bind(this))
    this.paneDiv.append(this.removeIcon)
    /**  */
    this.allPanes = allPanes
    this.allPanes.append(this.paneDiv)
  }

  loadRequestHandler(cb) {

    let readFile = (e) => {
      fetch(URL.createObjectURL(e.target.files[0]))
        .then(res => {
            return res.text()
        })
        .then(contents => {
            this.csvText = contents
            // use the call back
            cb()
        })
    }
    return (e) => {
      // create the input type, click it, have the fetch
      let inputFile = document.createElement("input")
      inputFile.type = "file"
      inputFile.onchange = readFile
      // trigger the opening of a file explorer window
      inputFile.click()
    }
  }
  removePane() {
    //call the application remover that was set on the class instance
    this.removeFromApplication(this.paneDiv.id)
    //actually remove paneDiv
    this.paneDiv.remove()
  }
}

class CtrlOp {



  /**
   *Creates an instance of CtrlOp. Options include fill column specification, filters, view radio buttons, and slice sliders.  Meaningful attributes of ctrlOp state sliderIndex, sliceName brainView, sliceData, (brain region data) initialColData, filteredColData,colName, csvData (region fill data)
   * @param {*} paneDiv This is the div created by the pane to hold the ctrloptions elements
   * @param {*} paneOb The pane Object that facilitates sharing of values set in the ctrlop and the canvas. Also useful to set values on the pane object for export of sessions.
   * @class CtrlOp
   */
  constructor(paneDiv, paneOb) {
    /**  */
    this.paneOb = paneOb
    let ctrlDiv = document.createElement("div")
    ctrlDiv.className = "ctrlDiv"
    // add a section to the ctrldiv that clicking and dragging will actually move the entire paneholder
    paneDiv.append(ctrlDiv)
    /**  */
    this.paneDiv = paneDiv
    /**  */
    this.ctrlDiv = ctrlDiv
    // this will be set to the canvas element to emit events that the canvas is set to listen for
    /**  */
    this.eTarget = undefined
  }
  /**
   *Set the eTarget class field to the param ele
   *
   * @param {*} ele This is an html element, in the case of this program, will only ever be the html5 Canvas element
   * @memberof CtrlOp
   */
  target(ele) {
    /**  */
    this.eTarget = ele
  }

  //
  /**
  *Main function for the setup of the Ctrlop actual elements and their values. This is called in the button click scope, where I believe we are permitted to perform an await before making the canvas
  *
  * @memberof CtrlOp
  */
  async init() {
    // setup the csvLoader button
    this.csvLoader()
    // setup the radio buttons
    this.mkradio("axial")
    this.mkradio("sagittal")
    this.mkradio("coronal")
    // selected is the radio button we have selected
    this.paneOb.brainView = "sagittal" // default
    this.paneOb.paneDiv.querySelector("#radiosagittal").checked = true

    // create the brain slice slider
    this.createSlider()

    // ensure that the slider only permits sagittal slice count
    this.paneOb.paneDiv.querySelector("#radiosagittal").click()
  }
  /**
   *This function creates a button that allows loading of a CSV data file. It also adds the result to the paneOb.
   *
   * @memberof CtrlOp
   */
  csvLoader() {
    // create buttons to upload csvData and sessionData
    let loadButton = document.createElement("button")
    let callback = ()=> {
        this.csvDataReader()
        this.createSelector()
    }
    
    let loadingCall = this.paneOb.loadRequestHandler(callback.bind(this))
    // how to make function that will call createSelector when the file has finished uploading
    loadButton.addEventListener("click", loadingCall)
    loadButton.innerHTML = "Upload CSV"
    this.ctrlDiv.append(loadButton)

  }
  /**
   *Parse the text version of the CSV and create an object with each column name as a field and the values store in a list. CSV must contain a column named region that has exact name matches to the atlas file's region names, if nothing is drawing when using new CSV this is likely the main problem. Uses the paneOb.csvText set at the creation of the application. 
   *
   * @memberof CtrlOp
   */
  csvDataReader() {
    // turn this.csvText into a json that has the names of the columns as fields, and each has an array which is the data that follows
    // NOTE each row must either end with a \r or a \n
    let lines = this.paneOb.csvText.replace(/\r?\n/g, "---").split("---")
    let headers = lines[0].split(",")
    this.paneOb.csvData = {}
    headers.map(e => {
      this.paneOb.csvData[e.toLowerCase()] = []
    })
    // read through the rest of the lines and add them to the data
    // although if this were running off a server, we could convert it right then, but then we have hippa concerns? ask dianne
    for (let iLine = 1; iLine < lines.length; iLine++) {
      let entries = lines[iLine].split(",")
      for (let i = 0; i < entries.length; i++) {
        this.paneOb.csvData[headers[i].toLowerCase()].push(entries[i])
      }
    }
  }
  /**
   *Generate a radio button element for the specified brain view direction. Also attach the events which are sent along to the Canvas eTarget to trigger redraws on the canvas upon changing the brain view options. Ultimate drawing requires slice values from the slider to exist, but won't crash the program without them. Error messages coming from these missing values will go away upon a user interacting with the slider.
   *
   * @param {*} view Will be one of the 3 options, axial, sagittal, or coronal
   * @memberof CtrlOp
   */
  mkradio(view) {
    let rad = document.createElement("input")
    rad.type = "radio"
    // inclusion of panediv.id  makes the selection specific to the pane so that other panes don't get un checked when a selection is made
    rad.id = "radio" + view
    rad.name = "view" + this.paneOb.paneDiv.id
    rad.value = view
    let label = document.createElement("label")
    label.innerHTML = view
    let div = document.createElement("div")
    div.className = "radcontainer"
    div.id = "radcontainer" + view
    label.append(rad)
    div.append(label)
    this.ctrlDiv.append(div)
    // add this.paneOb.brainView on change
    rad.addEventListener("click", () => {
      this.paneOb.brainView = rad.value
      // also update the max for the slider
      // there's a chance that th sliderSlices haven't been instantiated, but wont crash, just doesn't send event to thecanvas until user has specified a slice
      this.slider.max = this.sliderSlices[this.paneOb.brainView].length - 1
      let e = new Event("radiobuttonchanged")
      if (this.eTarget) {
        let slice = this.paneOb.regionBoundaryData[this.sliderSlices[this.paneOb.brainView][this.paneOb.sliderIndex]]
        this.paneOb.sliceData = slice
        this.eTarget.dispatchEvent(e)
      }
    })
  }
  /**
   *This is the part for creating the column selection area. The options are taken from the csvData object fields. This option specifies which column's values create the fill colors used in the program. Specification also generates the fillColFilter, and the altColFilters.
   *
   * @memberof CtrlOp
   */
  createSelector() {

    // get rid of previous select dropdown if it exists
    if (document.querySelector("#fillCol")) {
      document.querySelector("#fillCol").remove()
    }
    // this is the selection element that is populated by the column names in the csv

    let valueColumnSelect = document.createElement("select")
    valueColumnSelect.id = "fillCol"
    for (let key of Object.keys(this.paneOb.csvData)) {
      let option = document.createElement("option")
      option.value = key
      option.innerHTML = key
      valueColumnSelect.append(option)
    }
    this.ctrlDiv.append(valueColumnSelect)
    valueColumnSelect.onchange = () => {
      // make access to the selector possible
      this.paneOb.fillColValue = valueColumnSelect.value
      // parse the data into numeric
      let numericData = this.paneOb.csvData[valueColumnSelect.value].map(e => parseFloat(e))
      this.paneOb.initialColData = numericData

      // establish filters for the selected column of data
      this.createFilters()

      // trigger a valcolchange event
      // this will make the filters update themselves, and make the canvas redraw the 
      let e = new Event("valcolchange")
      // update the canvas columdata somehow
      if (this.eTarget) {
        // send it to the canvas
        this.eTarget.dispatchEvent(e)
      }
    }
  }
  /**
   *Helper function to generate a datastructure that specifies which region's boundaries are supposed to be drawn to the canvas according to the slider's position. Slices by View is an object with the 3 brain view fields, and a list of all the geojson filenames sorted as entries. Also creates the sliderMeasurements that populate the label next to the slice selection slider.
   *
   * @memberof CtrlOp
   */
  prepRangeData() {
    let slicesByView = {
      "sagittal": [],
      "axial": [],
      "coronal": []
    }
    for (let n in this.paneOb.regionBoundaryData) {
      if (n.search(/cor/) == 0) {
        slicesByView["coronal"].push(n)
      }
      if (n.search(/sag/) == 0) {
        slicesByView["sagittal"].push(n)
      }
      if (n.search(/ax/) == 0) {
        slicesByView["axial"].push(n)
      }
    }
    let sortfunc = (x, y) => {
      let xmm = parseInt(x.match(/(-?\d+\.?\d*?)(mm)?/)[1])
      let ymm = parseInt(y.match(/(-?\d+\.?\d*?)(mm)?/)[1])
      return xmm - ymm
    }
    slicesByView.axial.sort(sortfunc)
    slicesByView.sagittal.sort(sortfunc)
    slicesByView.coronal.sort(sortfunc)
    /**  */
    this.sliderSlices = slicesByView
    // get the array of values
    /**  */
    this.sliderMeasurements = {}
    this.sliderMeasurements.axial = slicesByView.axial.map(sl => {
      return (sl.match(/(-?\d+\.?\d*?mm)/)[1])
    })
    this.sliderMeasurements.sagittal = slicesByView.sagittal.map(sl => {
      return (sl.match(/(-?\d+\.?\d*?mm)/)[1])
    })
    this.sliderMeasurements.coronal = slicesByView.coronal.map(sl => {
      return (sl.match(/(-?\d+\.?\d*?mm)/)[1])
    })
  }
  /**
   *This creates the actual slider element and binds the events triggering canvas draws on changes to the slider.
   *
   * @memberof CtrlOp
   */
  createSlider() {
    //initiate the slider
    let range = document.createElement("input")
    range.id = "rangeslider"
    let label = document.createElement("label")
    label.id = "rangesliderlabel"
    range.name = "slicerange"
    range.type = "range"
    label.setAttribute("for", "slicerange")
    this.ctrlDiv.append(range)
    this.ctrlDiv.append(label)
    /**  */
    this.slider = range
    /**  */
    this.sliderlabel = label
    // makes several attributes helpful for handling slider change
    this.prepRangeData()
    // add the on input event emitter  for when slider moves
    this.slider.oninput = () => {
      /**  */
      this.selectedSliceIndex = parseInt(this.slider.value)
      // now determine which slice we are supposed to draw the boundaries of provided the selected brain view an the slice index
      let ind = parseInt(range.value)
      this.paneOb.sliderIndex = ind
      // name is helpful at time of export
      let name = this.sliderSlices[this.paneOb.brainView][ind]
      this.paneOb.sliceName = name
      this.sliderlabel.innerHTML = this.sliderMeasurements[this.paneOb.brainView][ind]
      this.paneOb.sliceMeasure = this.sliderlabel.innerHTML
      // provide the name of the slice to the canvas drawing machinery
      // sliderchange is a custom event that the canvas is listening for
      let e = new Event("sliderchange")
      if (this.eTarget) {
        let slice = this.paneOb.regionBoundaryData[this.sliderSlices[this.paneOb.brainView][this.paneOb.sliderIndex]]
        this.paneOb.sliceData = slice
        // dispatch to the eTarget the canvas
        this.eTarget.dispatchEvent(e)
      }
    }
  }
  /**
   *Prepare the filters. Remove the existing fillFilter if it exists so that duplicate elements don't get created. Perform the same thing for the AltColumnFilters holder.
   *
   * @memberof CtrlOp
   */
  createFilters() {
    if (this.fillFilter) {
      this.fillFilter.remove()
    }
    /**  */
    this.fillFilter = new FillColFilter(this.ctrlDiv, this.paneOb.initialColData, this.eTarget, this.paneOb)
    this.fillFilter.init()
    // set them at default values
    // categorical filters
    if (this.altFilters) {
      this.altFilters.remove()
    }
    /**  */
    this.altFilters = new AltHolder(this.ctrlDiv, this.paneOb)
    this.altFilters.init()


  }
}

class AltColumnFilters {
  /**
   *Creates an instance of AltColumnFilters.
   * @param {*} outerHolder This is the html div element holder for each row of filters.
   * @param {*} paneOb This is the pane object provided here to store values important to drawing the brain slice choropleth and exporting the session
   * @class AltColumnFilters
   */
  constructor(outerHolder, paneOb) {
    /**  */
    this.outerHolder = outerHolder
    /**  */
    this.paneOb = paneOb
    /**  */
    this.holder = document.createElement("div")
    this.holder.className = "altFilterRow"
    // used for tooltip and ultimate session export
    /**  */
    this.expInfo = {}
    //

  }

  /**
   *Process should look like, first have a selector for the column names of the csv then on select, detect whether you should make numerical or categorical options make selections for the == and != , then the unique column if categorical or input for numeric comparison
   *
   * @memberof AltColumnFilters
   */
  init() {
    this.outerHolder.append(this.holder)
    // create element that takes away the filter row
    /**  */
    this.removeBtn = document.createElement("button")
    this.removeBtn.innerHTML = "X"
    this.removeBtn.addEventListener("click", this.removeSelf.bind(this))
    this.holder.append(this.removeBtn)
    // make the first select element of the csv columns
    this.columnSelector()
  }
  /**
   *Find unique values of the selected column to populate the categorical value selector. Third item of the filter row
   *
   * @memberof AltColumnFilters
   */
  makeSelectUnique() {
    /**  */
    this.catSelect = document.createElement("select")
    this.catSelect.id = "val"
    for (let op of uniqueSet) {
      let option = document.createElement("option")
      this.catSelect.append(option)
      option.value = op
      option.innerHTML = op
    }
  }
  /**
   *The intial selector specifying which CSV column to use as the altFilter.Triggers operations and value selector creation on change 
   *
   * @memberof AltColumnFilters
   */
  columnSelector() {
    /**  */
    this.altColSelect = document.createElement("select")
    // the column names of the csv
    this.altColSelect.id = "colname"
    for (let colOption in this.paneOb.csvData) {
      //
      let option = document.createElement("option")
      this.altColSelect.append(option)
      option.value = colOption
      option.innerHTML = colOption
    }
    this.holder.append(this.altColSelect)
    // on change, replace the other elements with new operation and selector
    // run it once to set options for default selection
    this.generateOperations()
    this.altColSelect.onchange = this.generateOperations.bind(this)

  }
  /**
   *Handles creation of operation and value selector creation. Interprets the selected CSV column as categorical or numeric and provides the appropriate operation and value selector options. < or > for numeric. == or != for categorical. Also triggers initial creation of bool mask array created from iterating over the specified alternate column and comparing each element to the chosen operation and value. the boolmask 
   *
   * @memberof AltColumnFilters
   */
  generateOperations() {
    // remove previous elements if created
    if (this.operation) {
      this.operation.remove()
    }
    if (this.valueSelector) {
      this.valueSelector.remove()
    }
    // check whether the column is numeric
    this.expInfo["name"] = this.altColSelect.value
    this.paneOb.altFiltersState[this.id].colname = this.altColSelect.value
    if (parseFloat(this.paneOb.csvData[this.altColSelect.value][0])) {
      // the value was numeric, t
      /**  */
      this.operation = document.createElement("select")
      this.operation.id = "op"
      let equals = document.createElement("option")
      equals.innerHTML = "<"
      equals.value = "<"
      let notEquals = document.createElement("option")
      notEquals.innerHTML = ">"
      notEquals.value = ">"
      this.operation.append(equals)
      this.operation.append(notEquals)
      this.holder.append(this.operation)
      // create an input point for value input
      /**  */
      this.valueSelector = document.createElement("input")
      this.valueSelector.type = "text"
      this.valueSelector.id = "val"
      this.holder.append(this.valueSelector)
      this.operation.onchange = this.mask.bind(this)
      this.valueSelector.onchange = this.mask.bind(this)

    } else {
      // remove existing elements too
      // generate the == != select
      /**  */
      this.operation = document.createElement("select")
      this.operation.id = "op"
      let equals = document.createElement("option")
      equals.innerHTML = "=="
      equals.value = "=="
      let notEquals = document.createElement("option")
      notEquals.innerHTML = "!="
      notEquals.value = "!="
      this.operation.append(equals)
      this.operation.append(notEquals)
      this.holder.append(this.operation)

      // make a populated selector with unique options from the column
      this.findUniqueElements()
      /**  */
      this.valueSelector = document.createElement("select")
      this.valueSelector.id = "val"
      for (let op of this.uniqueSet) {
        //make an option with each
        let opele = document.createElement("option")
        opele.value = op
        opele.innerHTML = op
        this.valueSelector.append(opele)
      }
      this.holder.append(this.valueSelector)
      // do mask on both the selectors change
      this.operation.onchange = this.mask.bind(this)
      this.valueSelector.onchange = this.mask.bind(this)
      // mask using  defaults
      this.mask()
    }
  }

  /**
   *Generate a 0 1 vector to determine whether the filter should keep or toss a fillColumn value. Stores selected state of filter row in the paneOb.altFilterState and the expInfo fields. The altChange event is dispatched to tell the holder of the altFilters to filter the initialColData through each of the row's bool masks and only fill values on the canvas that come from rows that pass all altColumnFilters
   *
   * @memberof AltColumnFilters
   */
  mask() {
    this.expInfo["operation"] = this.operation.value
    this.expInfo["value"] = this.valueSelector.value
    this.paneOb.altFiltersState[this.id].op = this.operation.value
    this.paneOb.altFiltersState[this.id].val = this.valueSelector.value
    /**  */
    this.boolMask = this.paneOb.csvData[this.altColSelect.value].map(e => {
      if (this.operation.value == "==") {
        if (e == this.valueSelector.value) {
          return 1
        }
        return 0
      }
      if (this.operation.value == "!=") {
        if (e != this.valueSelector.value) {
          return 1
        }
        return 0
      }
      if (this.operation.value == ">") {
        if (e > parseFloat(this.valueSelector.value)) {
          return 1
        }
        return 0
      }
      if (this.operation.value == "<") {
        if (e < parseFloat(this.valueSelector.value)) {
          return 1
        }
        return 0
      }
    })
    // emit event on the holder that the altchanged
    let altchange = new Event("altchange")
    this.outerHolder.dispatchEvent(altchange)

  }
  /**
   *Generate a list of the unique elements of a column.
   *
   * @memberof AltColumnFilters
   */
  findUniqueElements() {
    /**  */
    this.uniqueSet = []
    for (let element of this.paneOb.csvData[this.altColSelect.value]) {
      if (this.uniqueSet.indexOf(element) == -1) {
        this.uniqueSet.push(element)
      }
    }
  }

  /**
   *Make it possible to take the filter row out of the AltHolder list.
   *
   * @memberof AltColumnFilters
   */
  removeSelf() {
    // triggered by clicking the exit button
    this.holder.remove()
    // take self out of the filter list on the AltHolder ob
    // this is a function set by the AltHolder on each row it creates
    this.removeFromList(this)
  }
}




class AltHolder {
  /**
   *Creates an instance of AltHolder. Generates a button to add altRows an instantiates the list to hold each filter object
   * @param {*} ctrlDiv The html element that the button and all the rows will live in
   * @param {*} paneOb The pane ob present here to assist in passing values to canvas to draw, and ultimately the export of a session
   * @class AltHolder
   */
  constructor(ctrlDiv, paneOb) {
    // button and larger div for the elements to get added in
    /**  */
    this.ctrlDiv = ctrlDiv
    /**  */
    this.paneOb = paneOb
    /**  */
    this.createAltRowBtn = document.createElement("button")
    this.createAltRowBtn.innerHTML = "Create Alt Column Filter"
    this.createAltRowBtn.id = "altfilterbutton"
    /**  */
    this.altfilters = []
  }
  /**
   *Start the idcount for each row used in the deletion  of rows and initialize the altFilterState field on the paneOb which is used for export
   *
   * @memberof AltHolder
   */
  init() {
    /**  */
    this.holder = document.createElement("div")
    this.holder.id = "altcolholder"
    this.createAltRowBtn.onclick = this.addRow.bind(this)
    this.holder.append(this.createAltRowBtn)
    this.ctrlDiv.append(this.holder)
    /**  */
    this.idCount = 0
    // attach the altfilters to the paneOb for export
    this.paneOb.altFiltersState = {}

  }
  /**
   *Function that is called upon clicking the add row button for the filterholder. Set the removal function that is to activate upon clicking the X button of the row. Set the listener to filter upon receiving an altchange event
   *
   * @memberof AltHolder
   */
  addRow() {
    let newAlt = new AltColumnFilters(this.holder, this.paneOb)
    newAlt.id = this.idCount
    this.idCount++
    // add to the pane collection for export as well
    this.paneOb.altFiltersState[newAlt.id] = { colname: "", op: "", val: "" }
    newAlt.init()
    // add the removal function to take it from the list too

    newAlt.removeFromList = this.removeFromList.bind(this)

    this.altfilters.push(newAlt)
    this.holder.addEventListener("altchange", this.filter.bind(this))


  }
  /**
   *iterate over the altfilters, and then only let through the ones that work with each bool mask reduce on the intiial paneob data iterate over all the individual boolmask values. Failing the criteria of even one of the altRows means that the ultimate filteredAltColData element at that index i should be NaN or correspond to a gray filled region. Dispatch the filtered change event and setup and draw results to the canvas.
   *
   * @memberof AltHolder
   */
  filter() {

    this.paneOb.filteredAltColData = this.paneOb.initialColData.map((e, i) => {
      let isNa = false
      for (let altfilter of this.altfilters) {
        if (altfilter.boolMask[i] == 0) {
          isNa = true
          break
        }
      }
      if (isNa) {
        return NaN
      } else {
        return e
      }
    })
    let e = new Event("filterChange")
    // get the canvas element
    this.paneOb.paneDiv.querySelector("canvas").dispatchEvent(e)

    // extract filter name information to use in the tooltip
    this.paneOb.altFilterInfo = ""
    for (let altfilter of this.altfilters) {
      //
      this.paneOb.altFilterInfo += JSON.stringify(altfilter.expInfo)
    }
  }
  /**
   *This function is provided to each row to assist in removing it from the active alt filtering options. Must also remove the filter from the paneOb so that exported sessions don't import the wrong filtering options.
   *
   * @param {*} ele bound to the this of the altfilter row. 
   * @memberof AltHolder
   */
  removeFromList(ele) {
    // go through the list and find the one that has the same values for the filtering elements
    // columnselector && operation && valueSelector
    let index = 0
    for (let filter of this.altfilters) {
      if (ele.id == filter.id) {
        // remove it from the list 
        this.altfilters.splice(index, 1)
        // also remove the entry from the paneob export object
        delete this.paneOb.altFiltersState[index]
        // trigger remask calculation so as not to confuse whats active
        this.filter()

      }
      index += 1
    }


  }
  /**
   *remove the altHolder. used for when fill columns need to generate a new set of filters, and duplicate elements are generated otherwise.
   *
   * @memberof AltHolder
   */
  remove() {
    this.holder.remove()
    this.createAltRowBtn.remove()
  }

}

class FillColFilter {
  /**
   *Creates an instance of FillColFilter.
   * @param {*} ctrlDiv the html element holder of the fill filter .
   * @param {*} data the intial data that will be filtered depending on the state of the min and max elements
   * @param {*} eventTarget this is the canvas element which we emit events to so that drawing occurs
   * @param {*} paneOb the paneobject which values are stored on so the canvas can reference, and exporting can occur
   * @class FillColFilter
   */
  constructor(ctrlDiv, data, eventTarget, paneOb) {
    /**  */
    this.min = undefined
    /**  */
    this.max = undefined
    /**  */
    this.ctrlDiv = ctrlDiv
    /**  */
    this.data = data
    /**  */
    this.eTarget = eventTarget
    /**  */
    this.paneOb = paneOb
  }
  //remove the previous filter elements
  /**
   *destroy the html elements corresponding to the filter to prevent duplicate elements from getting generated
   *
   * @memberof FillColFilter
   */
  remove() {
    this.minlabel.remove()
    this.maxlabel.remove()
    this.maxel.element.remove()
    this.minel.element.remove()
  }
  /**
   *initialize the fill filters. Generate a min and max div element that responds to mouse events that can slide within an area of 1/4th the width of the ctrldiv. Generate an interpolator to make - and + values possible given the data in the fill column that we are filtering. Additional Limit closures are provided to specialize the div objects of the divMaker class to each of the min and max responsibilities. Also set closure on paneOb that enables setting values without mouse involvement.
   *
   * @memberof FillColFilter
   */
  init() {
    // make a range slider that updates the self filter function which is called later on activity data
    let rangeWidth = this.ctrlDiv.getBoundingClientRect()
    let min = new divMaker(rangeWidth.width / 4, this.ctrlDiv)
    let max = new divMaker(rangeWidth.width / 4, this.ctrlDiv)


    // establish the absmin and absmax of the column data
    // raise hell if the data can't be sorted this way
    this.setbounds(Math.min(...this.data), Math.max(...this.data))
    // makes it easier to have the sliders present correct values even when negatives are involved
    /**  */
    this.interpolator = interpolator()
    // values of v go in which range from 0 to 1
    this.interpolator.setup(0, this.absmin, 1, this.absmax)

    /**  */
    this.maxel = max
    /**  */
    this.minel = min
    // make the draggable elements catch movement events and ensure that the filter method gets called when dragging stops
    this.maxel.element.addEventListener("divmoved", this.filter.bind(this))
    this.minel.element.addEventListener("divmoved", this.filter.bind(this))
    // this si the amount of screen space that the filter div's can move, minus the width of the element
    /**  */
    this.width = (rangeWidth.width / 4) - 30
    // create labels
    /**  */
    this.minlabel = document.createElement("p")
    this.minlabel.id = "minlabel"
    this.minlabel.className = "filterLabel"
    /**  */
    this.maxlabel = document.createElement("p")
    this.minlabel.id = "maxlabel"
    this.maxlabel.className = "filterLabel"
    let labelholder = document.createElement("div")
    labelholder.id = "labelholder"
    // prevent sliders from going over each other
    min.additionalLimit = (v) => {
      // stay below the max point
      let maxleft = parseInt(max.element.style.left)
      if (v > maxleft) {
        min.element.style.left = `${maxleft}px`
        /**  */
        this.min = maxleft
        // update min label
        this.minlabel.innerHTML = this.interpolator.calc(maxleft / this.width).toFixed(5)
        return true
      }
      // used at filter time
      /**  */
      this.min = v
      // update min label and account for the divslider width
      this.minlabel.innerHTML = this.interpolator.calc(v / this.width).toFixed(5)
      return false
    }
    max.additionalLimit = (v) => {
      let minleft = parseInt(min.element.style.left)
      if (v < minleft) {
        max.element.style.left = `${minleft}px`
        /**  */
        this.max = minleft
        this.maxlabel.innerHTML = this.interpolator.calc(minleft / this.width).toFixed(5)
        return true
      }
      this.maxlabel.innerHTML = this.interpolator.calc(v / this.width).toFixed(5)
      // used at filter time
      /**  */
      this.max = v
      return false
    }
    labelholder.append(this.minlabel, this.maxlabel)
    this.ctrlDiv.append(min.element)
    this.ctrlDiv.append(max.element)
    this.ctrlDiv.append(labelholder)
    // once placed, set this to keep in correct spot, make them sit on same line
    max.element.style.top = `-30px` // overlap the element with the other
    max.element.style.left = "50px"

    // provide a way to initialize values via styling from import
    this.paneOb.updateFillFilter = (importMin, importMax) => {
      // move the divs
      min.element.style.left = importMin + "px"
      max.element.style.left = importMax + "px"
      // populate the instance variables, and labels
      min.additionalLimit(importMin)
      max.additionalLimit(importMax)
    }
  }
  /**
   *Filter the initial data passed in upon filter construction and determine the fill value from interpolation on the min and max elements position on the screen. Store the values in the paneOb for export. generate a filteredFillColData on the paneOb for the canvas drawing. dispatch the filter change event.
   *
   * @memberof FillColFilter
   */
  filter() {
    // calculate the actual min activity value
    let fillmin = this.interpolator.calc(this.min / this.width).toFixed(5)
    let fillmax = this.interpolator.calc(this.max / this.width).toFixed(5)
    // give this information to the paneOb,useful for tooltips
    this.paneOb.valFilterMin = fillmin
    this.paneOb.valFilterMax = fillmax
    this.paneOb.filteredFillColData = this.data.map(e => {
      if (e >= fillmin && e <= fillmax) {
        return e
      }
      return NaN
    })
    // emit an actual canvas filtered event 
    let e = new Event("filterChange")
    this.eTarget.dispatchEvent(e)

  }
  /**
   *Establish the min and max values for the fill filter based on the parameters provided
   *
   * @param {*} absmin minimum value for the fill data
   * @param {*} absmax maximum value for the fill data
   * @memberof FillColFilter
   */
  setbounds(absmin, absmax) {
    /**  */
    this.absmax = absmax
    /**  */
    this.absmin = absmin
  }
}


class divMaker {
  /**
   *Creates an instance of divMaker. 
   * @param {*} width The width of the entire draggable range for the div, should be  1/4th the space of the ctrldiv element
   * @param {*} holder The element that the divs will live within, this should be the fill filter holder.
   * @class divMaker
   */
  constructor(width, holder) {
    let d = document.createElement("div")
    /**  */
    this.element = d
    d.style.height = "30px"
    d.style.width = "30px"
    d.style.position = "relative"
    d.style.margin = "0"
    let move = (e) => {
      let x = e.clientX - holder.getBoundingClientRect().left
      let left = x
      if (left > width - 30) { // because the size of the div at the moment is 30
        left = width - 30
      }
      if (left < 0) {
        left = 0
      }
      if (this.additionalLimit(left)) {
        console.log("stopped marker")
      } else {
        this.element.style.left = `${left}px`
      }
      /**  */
      this.v = parseInt(this.element.style.left)
    }
    let cancelMove = (e) => {
      console.log("cancelling")
      document.removeEventListener("mousemove", move)
      document.removeEventListener("mouseup", cancelMove)
      // emit event that canvas must redraw
      // right now there is no etarget because this is a makediv not a ctrlop
      let divEvent = new Event("divmoved")
      // dispatch it with the d, and listen on the min and max to emit filter calls
      d.dispatchEvent(divEvent)
    }
    let click = () => {
      document.addEventListener("mousemove", move)
      document.addEventListener("mouseup", cancelMove)
    }
    d.addEventListener("mousedown", click)
    d.style.background = "#00000052"
  }
  // this function is replaced in the instances of the object, class inheritance case
  additionalLimit(v) {
    return undefined
  }
}


class Canvas {

  /**
   *Creates an instance of Canvas. Holds stuff like the global min/max, the invisible and visible canvases, the boundary lines, and various interpolators use the ctrlInstance to get things like boundary data, and fill data when the values change use paneOb when there are needs for boundary data or filteredColData
   * @param {*} paneDiv Reference to the pane's div to add the canvas to
   * @param {*} paneOb paneOb reference for retrieving and storing data important for line paths, fills, and export of sessions
   * @param {*} size Size of the canvas element, will use this for both width and height
   * @param {*} margin Amount of white space around the drawing 
   * @class Canvas
   */
  constructor(paneDiv, paneOb, size, margin) {
    /**  */
    this.margin = margin
    /**  */
    this.size = size
    /**  */
    this.can = document.createElement("canvas")
    // the invisible canvas is used to assist with the mapping of clicks to uniquely colored regions whose pixels can be queried for color strings mapping to region names
    // easy hack to keep performance and accuracy of interactivity on canvas
    /**  */
    this.invisican = document.createElement("canvas")
    this.invisican.id = "invisican"
    // makes resizes not affect xy of canvas
    /**  */
    this.canvasHolder = document.createElement("div")
    this.canvasHolder.id = "canvasHolder"
    /**  */
    this.infoHolder = document.createElement("div")
    this.infoHolder.className = "infoHolder"
    // other versions of teh data will be around later,
    // get data for boundaries and selected value column
    /**  */
    this.paneDiv = paneDiv
    /**  */
    this.paneOb = paneOb
    this.paneOb.rois = {}
    // setup the text area for note taking
    this.paneOb.ta = document.createElement("textarea")
    //thi
  }
  /**
   *Generate a map of region names to actual numerical values. Store the object on the paneOb as dataForPlot to use in plotting tools.
   *
   * @memberof Canvas
   */
  makeRegDataMap() {
    /**  */
    this.regNameToValueMap = {}
    // drawregions without fill if nothing selected yet
    if (this.fillData == undefined) {
      this.paneOb.csvData["region"].map((e, i) => {
        this.regNameToValueMap[e.replace(/\s/, "")] = NaN
      })
    } else {
      this.paneOb.csvData["region"].map((e, i) => {
        this.regNameToValueMap[e.replace(/\s/, "")] = this.fillData[i]
      })
    }
    this.paneOb.dataForPlot = this.regNameToValueMap
  }
  /**
   *The initialization of the canvas. Add elements like the canvas (invisible one too), textarea, and infoholders to the canvasHolder field on the class. Create listeners for events that trigger setup and draw functions to execute.
   *
   * @memberof Canvas
   */
  init() {
    // setup the canvas
    this.canvasHolder.append(this.can)
    this.canvasHolder.append(this.paneOb.ta)
    this.canvasHolder.append(this.infoHolder)
    this.paneDiv.append(this.canvasHolder)
    this.can.height = this.size
    this.can.width = this.size
    this.invisican.height = this.size
    this.invisican.width = this.size
    //create interpolators for drawing
    //map xmin - xmax to 0 to 5000 or whatever width is do the same for y
    // create the regnametoValueMap
    /**  */
    this.ctx = this.can.getContext("2d")
    /**  */
    this.invisictx = this.invisican.getContext("2d")
    // calculate the regionSize min and max for all the slices, and allow us to scale the canvas content depending on that in the future
    this.calcRegionSizeGlobal()
    // take care of binding various functions to the events that get emitted
    // events to track valcolchange,radiobuttonchanged,sliderchange, filterChange
    // valcolchange we need to wait until something happens with the sliders?

    this.can.addEventListener("click", this.getPos.bind(this))
    //radiobutton and slider change have implications for the slice we are looking at
    this.can.addEventListener("radiobuttonchanged", () => {
      this.setupCanvas()
      this.drawCanvas()
    })
    this.can.addEventListener("sliderchange", () => {
      this.setupCanvas()
      this.drawCanvas()
    })

    //activity filter change, and valcolchange mean we must update our version of the ctrlInstance coldat, requires updating the regNameToValMap also
    this.can.addEventListener("filterChange", () => {
      this.setupCanvas()
      this.drawCanvas()
    })

  }
  // this is meant to query the ctrlInstance for what view and slice index we are on
  /**
   *This function determines what the final fill data should look like according to the presence or absence of FillFilters and AltFilters. Also uses this data to calculate global min and max of the fillData to use in color interpolation, and interpolators between the range of region coordinates and canvas screen space. Also Calculates the unique color set to fill in the invisible canvas for mouse queries.
   *
   * @memberof Canvas
   */
  setupCanvas() {
    // mingle the two filtered datasets 
    /**  */
    this.fillData = []
    // if both data filters aren't specified use whole initial range
    if (this.paneOb.filteredFillColData == undefined &&
      this.paneOb.filteredAltColData == undefined) {
      /**  */
      this.fillData = this.paneOb.initialColData
    } else if (this.paneOb.filteredFillColData == undefined && this.paneOb.filteredAltColData != undefined) {
      /**  */
      this.fillData = this.paneOb.filteredAltColData
    } else if (this.paneOb.filteredFillColData != undefined && this.paneOb.filteredAltColData == undefined) {
      /**  */
      this.fillData = this.paneOb.filteredFillColData
    } else {
      // if only the activity is specified
      // if both filters are around
      for (let i = 0; i < this.paneOb.initialColData.length; i++) {
        // if the two different filters have non NAN at that index add it to fill

        if (isNaN(this.paneOb.filteredAltColData[i]) || isNaN(this.paneOb.filteredFillColData[i])) {
          this.fillData.push(NaN)
        } else {
          this.fillData.push(this.paneOb.initialColData[i])

        }

      }
    }
    // will update the map used in the draw to determine the color of a region
    if (this.paneOb.csvData) {
    this.makeRegDataMap()
    }
    // initialize the color setting for the invisican
    let cc = color_collection(this.paneOb.sliceData.features.length)
    /**  */
    this.colToRegMap = {}
    /**  */
    this.regToColMap = {}
    this.paneOb.sliceData.features.map((f, i) => {
      // this is for the fill on the invisible canvas
      this.regToColMap[f.properties.regionName] = cc.array[i]
      this.colToRegMap[JSON.stringify(cc.array[i])] = f.properties.regionName
    })
    // this will happen at the beginning before column selection
    if (this.fillData != undefined) {
      this.calcValueColMinMax()
    }
    // create the region data to screen space interpolators
    let xinterp = interpolator()
    let yinterp = interpolator()
    // use correct ratio
    if (this.canvasRatio > 1) {
      xinterp.setup(this.regionSizes[0], 0 + this.margin, this.regionSizes[2], this.can.width / this.canvasRatio - this.margin)
      yinterp.setup(this.regionSizes[1], (this.can.height - this.margin), this.regionSizes[3], this.margin)// extra 10is the margin split intwo

    } else {

      xinterp.setup(this.regionSizes[0], 0 + this.margin, this.regionSizes[2], this.can.width - this.margin)
      yinterp.setup(this.regionSizes[1], this.can.height * this.canvasRatio - this.margin, this.regionSizes[3], this.margin)// extra 10is the margin split intwo
    }
    /**  */
    this.yinterp = yinterp
    /**  */
    this.xinterp = xinterp
  }
  /**
   *This function generates a div element with specific innerHTML to append to the infoholder. Only happens for mouseclicks within a region to generate information about the region beneath the canvas. These tooltips disappear when no longer viewing a slice that features that region.
   *
   * @param {*} regionName
   * @param {*} inner
   * @memberof Canvas
   */
  tooltipMaker(regionName, inner) {
    // make a little side box with the info in it
    // take away a chunk of the image at that area
    // remove any improper characters for the id
    let id = regionName.replace(/[-_]/g, "")
    let rightDiv = document.createElement("div")
    rightDiv.id = "tooltip" + id
    rightDiv.className = "tooltipholder"
    rightDiv.innerHTML = inner        //put new info in front of notes to canvas element if possible
    this.infoHolder.prepend(rightDiv)
    // add tooltip to the rois tooltip array
  }
  // add a tracker for regions clicked
  // populate elements on canvas like roi's which stores the region name, 
  // at draw time if region is in the roi list stroke it in purple, or green? ask josh what he thinks?
  // look at complementary colors for r b 
  // if they click in the same region again it should toggle it off and out of the listing
  /**
   *This function converts the position x,y of a mouseclick on the visible canvas into a pixel's rgb values taken from the invisible canvas where each region has unique filling colors. This rgb string then is used to determine which region the click originated in, and an entry is added to the regions of interest (rois) attribute on the canvas class, as well as the paneOb. We then redraw to include a yellow border around the region that was clicked
   *
   * @param {*} e the mouse click event
   * @memberof Canvas
   */
  getPos(e) {
    // the drawing holds both canvases, so we can get the x,y from the click, and apply it to the invisible can
    let rect = this.can.getBoundingClientRect()
    let x = e.clientX - rect.left
    let y = e.clientY - rect.top
    let ctx = this.invisictx
    // activate the border point-in-polygon algorithm
    // get image data
    // loop until we move right to get a pix value that is above certain threshold green
    let pix = Array(...ctx.getImageData(x, y, 1, 1).data.slice(0, 3))
    // query the invisible map
    if (this.colToRegMap[JSON.stringify(pix)] != undefined) {
      let regionName = this.colToRegMap[JSON.stringify(pix)]
      if (this.paneOb.rois[regionName] != undefined) {
        delete this.paneOb.rois[regionName]
      } else {
        this.paneOb.rois[regionName] = `
            <h3>Selected Region
              <p class="tooltip-child" id="regionname">
                    ${ regionName}
              </p>
              <p class="tooltip-child">
            <p>value: ${this.regNameToValueMap[regionName].toFixed(5)}
            </p><p>view: ${this.paneOb.brainView}
            </p><p>fillColumnFilter: ${this.paneOb.valFilterMin} <= value <= ${this.paneOb.valFilterMax} 
            </p><p>slice: ${this.paneOb.sliceMeasure}

              </p><p>altfilterinfo:${this.paneOb.altFilterInfo}</p>
            </h3>
            `
      }
      // do a redraw
      this.drawCanvas()
    }
  }

  /**
   *Figure out how much actual space the brain region data takes up. Important for setting the bounds of the interpolator that converts from region coordinate space to canvas space
   *
   * @memberof Canvas
   */
  calcRegionSizeGlobal() {
    // this should only get done once
    // scanCol is the column that has the data we care about putting in the color fill
    // this returns a summary object that knows things about the size of the brain json dimensions and also the min and max of hte scan data
    //!! should only do this part once
    let globals = [1000, 1000, -1000, -1000]
    for (let sliceName in this.paneOb.regionBoundaryData) {
      let slice = this.paneOb.regionBoundaryData[sliceName]
      for (let feature of slice.features) {
        // likely nota  loop because coordinates is a single element array
        for (let line of feature.geometry.coordinates) {
          for (let pt of line) {
            if (pt[0] < globals[0]) {
              globals[0] = pt[0]
            }
            if (pt[1] < globals[1]) {
              globals[1] = pt[1]
            }
            if (pt[0] > globals[2]) {
              globals[2] = pt[0]
            }
            if (pt[1] > globals[3]) {
              globals[3] = pt[1]
            }
          }
        }
      }
    }
    /**  */
    this.regionSizes = globals
    /**  */
    this.canvasRatio = globals[3] / globals[2]
  }

  /**
   *Calculate the min and max of the fill column provided to the canvas class
   *
   * @memberof Canvas
   */
  calcValueColMinMax() {
    /**  */
    this.scanDatamin = 0
    /**  */
    this.scanDatamax = 0
    for (let row of this.fillData) {
      if (row > this.scanDatamax) {
        /**  */
        this.scanDatamax = parseFloat(row)
      }
      if (row < this.scanDatamin) {
        /**  */
        this.scanDatamin = parseFloat(row)
      }
    }
    // this normalizes the value from the scan data into the range 0 to 1 for color interpolation
    let valToColInterp = interpolator()
    valToColInterp.setup(this.scanDatamin, 0, this.scanDatamax, 1)
    /**  */
    this.valToColInterp = valToColInterp
    // calculate the min and maxes of the scan data for each scan
  }

  /**
   *The all important drawing function. Responsible for clearing out old tooltips, generating color interpolators (gray to red + values) (blue to gray for - values). Actual lines are created by iterating over the features of the geojson slice specified by the brain view and the slider. paths are created for the visible and invisible canvases, and yellow strokes are provided for areas that are specified in the rois field on the canvas class. Fill values are linearly interpolated to the color scheme selected if the value for the specific isn't NaN.
   *
   * @memberof Canvas
   */
  drawCanvas() {
    //TODO find better version of how to structure so that the margin can be programmatically set
    this.ctx.clearRect(0, 0, this.can.width, this.can.height)
    this.invisictx.clearRect(0, 0, this.can.width, this.can.height)
    // remove previous tooltips
    while (this.infoHolder.firstChild) {
      this.infoHolder.removeChild(this.infoHolder.firstChild)
    }
    let red = {
      r: 255,
      g: 0,
      b: 0,
    }
    let gray = {
      r: 128,
      g: 128,
      b: 128
    }
    let blue = {
      r: 0,
      g: 0,
      b: 255
    }
    // iterate over the boundary data
    for (let region of this.paneOb.sliceData.features) {
      // this is the object that has features, and properties
      for (let coords of region.geometry.coordinates) {
        this.ctx.beginPath()
        this.invisictx.beginPath()
        // create simplified variable with points and region name
        let linedata = { points: coords, region: region.properties.regionName }

        // begin actual drawing to the canvas
        let first = linedata.points[0]
        let x = this.xinterp.calc(first[0])
        let y = this.yinterp.calc(first[1])
        this.ctx.moveTo(x, y)
        this.invisictx.moveTo(x, y)
        for (let i = 1; i < linedata.points.length; i++) {
          let pt = linedata.points[i]
          let x = this.xinterp.calc(pt[0])
          let y = this.yinterp.calc(pt[1])
          this.ctx.lineTo(x, y)
          this.invisictx.lineTo(x, y)
        }
        this.ctx.closePath()
        this.invisictx.closePath()
        // check if its a roilisted
        if (this.paneOb.rois[linedata.region]) {
          if (this.paneOb.rois[linedata.region]) {
            this.ctx.strokeStyle = "yellow"
            this.ctx.lineWidth = 5
            this.ctx.stroke()
          }
          // add tooltips that are visible
          let regId = linedata.region.replace(/[-_]/g, "")
          // if we don't find the element must make the tooltip
          if (!document.getElementById(`tooltip${regId}`)) {
            this.tooltipMaker(linedata.region, this.paneOb.rois[linedata.region])
          }
        }

        // default fill gray, update if nec
          this.ctx.fillStyle = "gray"
          this.ctx.fill()
        // these aren't defined yet
        if (this.regNameToValueMap != undefined) {
          if (this.regNameToValueMap[linedata.region]) {
            let scanData = this.regNameToValueMap[linedata.region]
            let t = this.valToColInterp.calc(scanData)
            let lerpc
            if (scanData < 0) {
              // use the blue to gray instead of gray to red
              lerpc = LerpCol(blue, gray, t)
            } else {
              lerpc = LerpCol(gray, red, t)
            }
            this.ctx.fillStyle = lerpc
            this.ctx.fill()
            // query the region to color map
          } 
        }
        this.invisictx.fillStyle = `rgb(${this.regToColMap[linedata.region][0]},${this.regToColMap[linedata.region][1]},${this.regToColMap[linedata.region][2]})`
        this.invisictx.fill()
      }
    }
  }
}

// non full blown classes
/**
 *Color collection is a tool to break the 3d color space of values 0-255,0-255,0-255 into rnum distict values that can be used to uniquely identify the region that a mouse click has occured within.
 *
 * @param {*} rnum Number of regions to generate color combinations for
 * @returns {}
 * 
 */
let color_collection = (rnum) => {
  ob = {}
  // this is the number of color chunks for each of the rgb channels
  let colordim = Math.ceil(Math.pow(rnum, 1 / 3))
  ob.array = []
  // nesting 3 deep, but each should be short
  for (let r = 0; r < colordim; r++) {
    for (let g = 0; g < colordim; g++) {
      for (let b = 0; b < colordim; b++) {
        let base = 255 / colordim // the base is permuted by each of the rgb loop variables
        // must round because the canvas sampling by pixel doesn't return floats
        ob.array.push([Math.round(base * r), Math.round(base * g), Math.round(base * b)])
      }
    }
  }
  return ob
}

/**
 *Standard parametric interpolation. Provided x0 y0 and x1 y1, generate a formula for a line that lets  us calculate a y value for a certain x. Used for region coordinate space to canvas space, and div style to fill value  conversions.
 *
 * @returns {}
 */
let interpolator = () => {
  let ob = {}
  ob.setup = (x0, y0, x1, y1) => {
    ob.x0 = x0
    ob.y0 = y0
    ob.x1 = x1
    ob.y1 = y1
  }
  ob.calc = (x) => {
    return (ob.y1 - ob.y0) / (ob.x1 - ob.x0) * x + (ob.x1 * ob.y0 - ob.y1 * ob.x0) / (ob.x1 - ob.x0)
  }
  return ob
}

/**
 *Generate an interpolator for colors between two specified colors (rgb).  
 *
 * @param {*} c1 a color object {r:num,g:num,b:num}
 * @param {*} c2 another color object {r:num,g:num,b:num}
 * @param {*} t numeric value 0 to 1 
 * @returns {}
 */
let LerpCol = (c1, c2, t) => {
  let red = Math.round(c1.r + (c2.r - c1.r) * t)
  if (red > 255) {
    red = 255
  }
  let blue = Math.round(c1.b + (c2.b - c1.b) * t)
  if (blue > 255) {
    blue = 255
  }
  let green = Math.round(c1.g + (c2.g - c1.g) * t)
  if (green > 255) {
    green = 255
  }
  return `rgb(${red},${green},${blue})`

}


let appHolder = document.querySelector("#applicationHolder")
var app = new Application(appHolder, atlas, csvData, sessionData)

// provide loaders for session and csv data sources
var csvData, sessionData
let Handler = () => {
}


app.runApp()

%% md

## Graphs using plotly from the data shown in the imaging panes.


%% fetch
js: https://cdn.plot.ly/plotly-latest.min.js

%% md

<div id="plotholder"></div>
%% js

let x = Object.keys(app.panes[0].dataForPlot)

let y = Object.values(app.panes[0].dataForPlot)


let plot = document.querySelector("#plotholder")
Plotly.plot(plot,[{
  x,y,
  type:"bar"
}])